package com.example.demo.ch08;

/**
 * リスト8.A 値の制約がある年齢クラス</br>
 * 十分なユニットテストを行うには、１種類の入力値についてテストするだけでは、不十分です。</br>
 * テスト対象メソッドによっては、多くの入力値について似たようなテストケースを作成しなければなりません。</br>
 * すると、テストケースが非常に多くなるにも関わらず、テストケースごとの差異は入力値と期待値のみになります。</br>
 * このため、入力値と期待値をテストケースとは独立して定義し、それらをテストメソッドのパラメータとして利用できるものであれば、ユニットテストの見通しが良くなり、入力値と期待値を追加することも容易になります。</br>
 * このようなユニットテストの手法はパラメータ化テストと呼ばれます。</br>
 * Junitでは@ParameterizedTestを使用する事で実現します。</br>
 * ・妥協な値の範囲を制限する。</br>
 * 会員制サイトの例では、年齢をint型とし、同値クラスに対するテストの値として「10と20」などと選択しました。</br>
 * ここで「−1と3000」を選択してもテスト結果に変わりませんが、年齢というパラメータでそのような値は不正なあたいとも言えます。</br>
 * このような場合、パラメータが妥当である範囲を制限することでテストも効率的になります。</br>
 * ひとつの実装方法としては、メソッドの仕様に「年齢が１以上150未満出ない場合は例外を送出する」と加える事です。</br>
 * そうすれば、入力値の有効範囲が1から149までとなり、全ての値のテストも実施可能な範囲となります。</br>
 * このテストでは全ての年齢についてテストすることは意味がないかもしれませんが、状況によっては有効な手段です。</br>
 * もちろん、テストデータとして−1や3000を追加し、正しく例外が送出されるかを検証しなければなりません。</br>
 * この実装とテストが必要かどうかは、そのソフトウェアがどの程度の品質を必要とするかに依存します。</br>
 * 会員制サイトでは、年齢を間違えて3000と入力して登録したとしても、ビジネス上に大きな問題はないかと思われます。</br>
 * しかし、証券取引システムで売買数をマイナスで入力できたり、億単位の発注数の入力を受け付けてしまったならば、取り返しのつかない問題となるでしょう。</br>
 * また、他の設計方針として、年齢をオブジェクトとして扱い、制約を加える方法があります。（リスト8.A）</br>
 * このAgeクラスを使ってリストを書き換えるとリスト8.Bのようになります。</br>
 * このように値をドメインに特化したオブジェクトとすることでソフトウェアはより堅牢になります。</br>
 * しかしながら、シンプルさとトレードオフになります。</br>
 * 
 * 
 * @author shuji.w6e
 */
public class Age {
	public final int value;

	public Age(int value) {
		if (value < 0 || 150 <= value)
			throw new IllegalArgumentException();
		this.value = value;
	}

}
