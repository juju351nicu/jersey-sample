package com.example.demo.ch06;

/**
 * リスト6.1 ItemStockインタフェース テストケースをグループ化する。<br/>
 * テストケースをグループ化する方針としては大きく2つの方法があります。<br/>
 * ①テストケースで検証する操作（メソッド）単位でグループ化する。<br/>
 * ②テストケースを共通の初期化処理を含むものでグループ化する。<br/>
 * 例えば、商品を管理するItemStockインタフェース（下記）に対するテストコードを整理することを考えます。
 * このインタフェースに対するテストケースを、次のように抽出したとします。 </br>
 * </br>
 * ①テストケースで検証する操作（メソッド）単位でグループ化</br>
 * ---------------------------------------------------------------------------------------------------------</br>
 * 検証するメソッド•••••••初期化処理•••••••••••••••••••••••••••••アサーション•••••••••••••••••••••••••••••••••••••</br>
 * ---------------------------------------------------------------------------------------------------------</br>
 * size••••••••••••••••ItemStockを作成する•••••••••••••••••••••sizeに商品Aを指定すると0を返す。•••••••••••••••••••</br>
 * ••••••••••••••••••••ItemStockを作成し、商品Aを2個追加する••••••sizeに商品Aを指定すると2を返す。•••••••••••••••••••</br>
 * contains••••••••••••ItemStockを作成する•••••••••••••••••••••containsに商品Aを指定するとfalseを返す。•••••••••••</br>
 * ••••••••••••••••••••ItemStockを作成し、商品Aを2個追加する••••••containsに商品Aを指定するとtrueを返す。••••••••••••</br>
 * add•••••••••••••••••ItemStockを作成する•••••••••••••••••••••addで商品Aを1個追加すると商品Aのsizeが1を返す。••••••</br>
 * ••••••••••••••••••••ItemStockを作成し、商品Aを2個追加する••••••addで商品Aを3個追加すると商品Aのsizeが5を返す。••••••</br>
 * ---------------------------------------------------------------------------------------------------------</br>
 * ②共通の初期化処理によるグループ化。</br>
 * ---------------------------------------------------------------------------------------------------------</br>
 * 初期化処理••••••••••••検証するメソッド•••••••••••••••••••••••••アサーション•••••••••••••••••••••••••••••••••••••</br>
 * --------------------------------------------------------------------------------------------------------</br>
 * ItemStockを作成する•••size••••••••••••••••••••••••••••••••••sizeに商品Aを指定すると0を返す。•••••••••••••••••••</br>
 * ••••••••••••••••••••contains••••••••••••••••••••••••••••••containsに商品Aを指定するとfalseを返す。•••••••••••</br>
 * ••••••••••••••••••••add•••••••••••••••••••••••••••••••••••addで商品Aを1個追加すると商品Aのsizeが1を返す。••••••</br>
 * ItemStockを作成し、•••size••••••••••••••••••••••••••••••••••sizeに商品Aを指定すると2を返す。•••••••••••••••••••</br>
 * 商品Aを2個追加する•••••contains••••••••••••••••••••••••••••••containsに商品Aを指定するとtrueを返す。••••••••••••</br>
 * ••••••••••••••••••••add•••••••••••••••••••••••••••••••••••addで商品Aを3個追加すると商品Aのsizeが5を返す。••••••</br>
 * ---------------------------------------------------------------------------------------------------------</br>
 * 上記どちらの方針であっても、テストはグループ化されます。</br>
 * しかしながら、各グループのテストケースを別個のテストクラスに定義することでテストケースの構造化を行うならば、大きな違いがあります。</br>
 * 検証する操作（メソッド）でのグループ化では、テストケースごとにテストの前提条件が異なるため、初期化処理を共通化できません。</br>
 * 一方共通の初期化処理でのグループ化では、初期化処理を共通化できます。</br>
 * テストの前提条件を初期化メソッドに抽出すると、テストメソッドの見通しがよくなります。</br>
 * また、各テストケースで前提条件が共通しているならば、効率よくテストコードの重複を減らすことができます。</br>
 * 従って初期化処理を共通化できるように、テストケースは共通の初期化処理でグループ化すべきです。</br>
 * しかしながら、テストケースを複数のテストクラスに分割して整理しようとすると、テストクラスを複数定義する必要があります。</br>
 * これは、テストクラスの命名規則の観点で望ましくはありません。</br>
 * この問題を解決するための仕組みが＠Nestedを利用したテストクラスの構造化です。</br>
 * 
 * @author shuji.w6e
 */
public interface ItemStock {

	/**
	 * 商品と数量を指定して追加する
	 * 
	 * @param item 商品名
	 * @param num  追加する数量
	 */
	void add(String item, int num);

	/**
	 * 商品を指定して、商品の在庫数を返す
	 * 
	 * @param item 商品名
	 * @return 在庫数、登録されていない場合は0
	 */
	int size(String item);

	/**
	 * 商品の在庫が残っている場合にtrueを返す
	 * 
	 * @param item 商品名
	 * @return 在庫が1以上の場合にtrue
	 */
	boolean contains(String item);
}