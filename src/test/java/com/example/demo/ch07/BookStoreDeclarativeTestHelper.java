package com.example.demo.ch07;

/**
 * ユニットテストは、「事前準備」「実行」「検証」「後処理」の４フェーズで行われます。（４フェーズテスト）</br>
 * 「事前準備」はテストに必要なデータ、環境、オブジェクトの状態などを準備する重要なフェーズ</br>
 * 「後処理」は次のテストに影響が出ないように、そのテストで作成したデータ、環境、オブジェクトの状態などを適切に解放する必要があります。</br>
 * この章では、これらの事前準備や後処理で扱うデータや実行環境を扱うパターンについて解説します。</br>
 * 7.1テストフィクスチャとは？</br>
 * ソフトウェアテストは、テスト対象となるシステムやオブジェクトだけでは成立しません。</br>
 * 入力するデータ、テスト実行のための予備操作、データベースなどの外部リソース、検証に必要なデータなどが必要不可欠です。</br>
 * これらのテストで扱うデータやテスト実行環境、オブジェクトの状態はテストフィクスチャ（test
 * fixtures）、もしくは単純にフィクスチャ(fixture)と呼ばれます。</br>
 * ・ユニットテストのフィクスチャ</br>
 * ユニットテストのフィクスチャには次の要素が含まれます。</br>
 * ・テスト対象オブジェクト</br>
 * ・テストの実行に必要なオブジェクト（入力値）</br>
 * ・テストの検証に必要なオブジェクト（期待値）</br>
 * ・テストの実行までに必要なテストオブジェクトの操作</br>
 * ・ファイルなどの外部リソース</br>
 * ・データベースやソケットサーバなどの外部システム</br>
 * ・依存クラスや依存外部システムのモックオブジェクト</br>
 * ユニットテストの事前準備フェーズでは、これらのフィクスチャを適切にセットアップする必要があります。</br>
 * もし、意図するフィクスチャがセットアップ出来なければ、不完全なテストケースです。</br>
 * ユニットテストのテストケースでは、原則として、1回だけテスト対象メソッドの操作を行うため、実行フェーズのコードは数行です。</br>
 * 一方、フィクスチャのセットアップのコードは長く、複雑になります。</br>
 * このため、テストコードの可読性を高めるためには、フィクスチャのセットアップをどのように工夫するかが重要です。</br>
 * 特に多くの入力値を持ち外部リソースに依存するテスト対象クラスでは、注意してフィクスチャのセットアップを行う必要があります。</br>
 * リスト7.A Javaによる宣言的なセットアップ ・フレッシュフィクスチャ</br>
 * ユニットテストでは、「フィクスチャはテストケースごとに独立し、テストの実行ごとに初期化され、終了時に解放する」が基本的な戦略です。</br>
 * この戦略は、フレッシュフィクスチャ（fresh fixture）と呼ばれます。</br>
 * フレッシュフィクスチャは「テストケースはお互いに独立しており、依存しあってはならない。」というユニットテストの原則と相性の良い戦略です。</br>
 * もし、フィクスチャがいくつかのテストケースで共有されていたならば、テストケースの実行順序などによってフィクスチャの状態が影響を受けるかもしれません。</br>
 * すると、テストの実行順序によってテスト結果が変わる可能性が生まれます。</br>
 * また、ユニットテストを並列に実行した場合、共有されたフィクスちゃが同時に複数のテストから利用される為、問題はより深刻になります。</br>
 * JUnitでは、テストの実行時にテストケースごとにテストクラスのインスタンスを生成し、テストメソッドを実行します。</br>
 * この為、テストクラスのインスタンス変数やローカル変数に保持されたテストデータは、各テストの終了時に、ガベージコレクタによって破棄されます。</br>
 * つまり、各テストケースでフィクスチャが共有されることはありません。</br>
 * 一方シングルトンとして設計されたクラスやデータベースなどの外部リソースでは、データを共有せざるを得ません。</br>
 * テストを並列に実行しない、初期化と後始末を丁寧に行うなど、特別な注意が必要です。</br>
 * ・フィクスチャとスローテスト問題</br>
 * フレッシュフィクチャは基本的なフィクスチャのセットアップパターンです。</br>
 * しかしながら、データベースを扱うテストなどでは、フィクスチャのセットアップに長い時間がかかることになります。</br>
 * このような問題はスローテスト問題（slow tests）と呼ばれます。</br>
 * 原因は、フィクスチャのセットアップごとに対象となるテーブルの全レコードを削除し、必要なレコードを追加するからです。</br>
 * この為、テストケースが増えてくると、全テストの実行に半日以上かかる場合もあります。</br>
 * ストーテスト問題を解決するには、テストの並列実行や共有フィクスチャ、カテゴリ化テストなどが有効です。</br>
 * テストの並列実行では、マルチスレッドや複数のテスト環境で並列にテストを実行し、効率化を図ります。</br>
 * 後術する共有フィクスチャでは、同一のフィクスチャを共有して使うことでセットアップコストを抑えます。</br>
 * カテゴリ化テストでは、テストをいくつかのグループに分け、実行するテストをフィルタリングします。</br>
 * カテゴリ化テストについては、第10章で解説します。</br>
 * なお、テストケースが少ない場合や、データベースや外部サービスへの通信を含むテストケースが少ない場合には、スローテスト問題が発生することはほとんどありません。</br>
 * また、スローテスト問題は、ユニットテストの実行時間が何十分もかかるようになってから対応するべきです。</br>
 * 原則としてユニットテストはお互いに独立し、全てのテストを行ってください。</br>
 * ・共有フィクスチャ</br>
 * 共有フィクスチャ（shared fixture）はスローテスト問題を解決するための手段の1つです。</br>
 * 共有フィクスチャでは、各テストケースで使用するフィクスチャを共有し、再利用することで、セットアップのコストを抑えます。</br>
 * しかしながら、共有フィクスチャには多くの問題があります。</br>
 * 最大の問題は、テストケースごとの独立性が弱くなります。</br>
 * テストケースの実行順序や他のテストケースの実行結果によって、共有化されたフィクスチャが影響を受け、別のテストケースに影響を与えるかもしれません。</br>
 * また、テストコードのメンテナンス性も低下します。</br>
 * あるフィクスチャをどのテストコードが参照ているのかがわからなくなり、グローバル変数と同様の問題を引き起こします。</br>
 * さらに、共有フィクスチャでは適切に後処理を行う必要があります。</br>
 * 従って可能な限りフィクスチャは共有しない方が良いでしょう。</br>
 * なお、共有フィクチャを不変オブジェクトとすれば、多くの問題は解決します。</br>
 * 状態がわからない不変オブジェクトであれば、テストの実行順序や結果、さらには並列実行の場合でも問題にならない。</br>
 * 
 * 
 * @author shuji.w6e
 */
public class BookStoreDeclarativeTestHelper {

	public static Book Bookオブジェクトの作成_MartinFowlerのRefactoring() {
		return new Book() {
			{
				title = "Refactoring";
				price = 4500;
				author = new Author() {
					{
						firstName = "Martin";
						lastName = "Fowler";
					}
				};
			}
		};
	}

}
